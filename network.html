<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Network Analysis - Artfictions</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <style>
    #network-container {
      width: 100%;
      height: 80vh;
      border: 1px solid var(--grey-mid);
      border-radius: 4px;
      margin: 1rem 0;
      background: var(--bg);
      position: relative;
    }
    
    #network-svg {
      width: 100%;
      height: 100%;
    }
    
    .node {
      stroke: var(--grey-dark);
      stroke-width: 1.5px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .node:hover {
      stroke-width: 3px;
    }
    
    .link {
      stroke: var(--grey-mid);
      stroke-opacity: 0.6;
      transition: all 0.3s ease;
    }
    
    .node-label {
      font-family: Inter, sans-serif;
      font-size: 11px;
      font-weight: 600;
      text-anchor: middle;
      pointer-events: none;
      fill: var(--fg);
    }
    
    .tooltip {
      position: absolute;
      background: var(--fg);
      color: var(--bg);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 1000;
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin: 1rem 0;
      padding: 1rem;
      background: var(--grey-light);
      border-radius: 4px;
    }
    
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .control-group label {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--grey-dark);
    }
    
    .control-group input[type="range"] {
      width: 150px;
    }
    
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin: 1rem 0;
      padding: 1rem;
      background: var(--grey-light);
      border-radius: 4px;
      font-size: 0.9rem;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .legend-circle {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid var(--grey-dark);
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }
    
    .stat-card {
      padding: 1rem;
      background: var(--grey-light);
      border-radius: 4px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--fg);
    }
    
    .stat-label {
      font-size: 0.9rem;
      color: var(--grey-dark);
      margin-top: 0.5rem;
    }
    
    .back-link {
      display: inline-block;
      margin-bottom: 1rem;
      color: var(--fg);
      text-decoration: none;
      font-weight: 600;
    }
    
    .back-link:hover {
      text-decoration: underline;
    }
    
    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
        align-items: stretch;
      }
      
      .control-group input[type="range"] {
        width: 100%;
      }
      
      #network-container {
        height: 60vh;
      }
    }
  </style>
</head>
<body>
<main>
  <a href="index.html" class="back-link">← Back to Catalogue</a>
  
  <h1>Theme Network Analysis</h1>
  
  <p>This visualisation shows how themes co-occur across the artfiction corpus. Nodes represent themes, and connections indicate themes that appear together in novels. Larger nodes represent more popular themes, and thicker connections show stronger thematic relationships.</p>
  
  <div class="stats" id="stats"></div>
  
  <div class="controls">
    <div class="control-group">
      <label for="minConnections">Minimum connections</label>
      <input type="range" id="minConnections" min="1" max="10" value="2" step="1">
      <span id="minConnectionsValue">2</span>
    </div>
    
    <div class="control-group">
      <label for="nodeSize">Node size multiplier</label>
      <input type="range" id="nodeSize" min="0.5" max="3" value="1" step="0.1">
      <span id="nodeSizeValue">1.0</span>
    </div>
    
    <button type="button" id="resetZoom">Reset view</button>
  </div>
  
  <div class="legend">
    <div class="legend-item">
      <div class="legend-circle" style="background: #1f77b4;"></div>
      <span>Theme nodes (size = frequency)</span>
    </div>
    <div class="legend-item">
      <div style="width: 20px; height: 2px; background: var(--grey-mid);"></div>
      <span>Co-occurrence links (thickness = strength)</span>
    </div>
  </div>
  
  <div id="network-container">
    <svg id="network-svg"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>
  
  <div id="analysis-text">
    <h2>Analysis</h2>
    <div id="analysis-content">
      <p>Loading network analysis...</p>
    </div>
  </div>
</main>

<script>
(async function() {
  const DATA_URL = 'artfictions_novels.json';
  
  // Load and process data
  let novels;
  try {
    const res = await fetch(DATA_URL);
    if (!res.ok) throw new Error(res.status);
    novels = await res.json();
  } catch (e) {
    console.error(e);
    document.getElementById('analysis-content').innerHTML = '<p style="color: #b00;">Failed to load data.</p>';
    return;
  }
  
  if (!Array.isArray(novels)) {
    const key = Object.keys(novels).find(k => Array.isArray(novels[k]));
    novels = key ? novels[key] : [];
  }
  
  // Process themes for each novel
  novels.forEach(n => {
    const themes = [];
    for (let i = 1; i <= 5; i++) {
      const theme = n[`Theme ${i}`];
      if (theme && theme.trim()) {
        themes.push(theme.trim());
      }
    }
    n.__themes = themes;
  });
  
  // Build theme network data
  function buildNetworkData(minConnections = 2) {
    const themeFreq = new Map();
    const themeCooccurrence = new Map();
    
    // Count theme frequencies and co-occurrences
    novels.forEach(novel => {
      const themes = novel.__themes;
      
      // Count individual themes
      themes.forEach(theme => {
        themeFreq.set(theme, (themeFreq.get(theme) || 0) + 1);
      });
      
      // Count co-occurrences
      for (let i = 0; i < themes.length; i++) {
        for (let j = i + 1; j < themes.length; j++) {
          const pair = [themes[i], themes[j]].sort().join('|');
          themeCooccurrence.set(pair, (themeCooccurrence.get(pair) || 0) + 1);
        }
      }
    });
    
    // Create nodes
    const nodes = Array.from(themeFreq.entries())
      .map(([theme, freq]) => ({
        id: theme,
        frequency: freq,
        connections: 0
      }));
    
    // Create links
    const links = Array.from(themeCooccurrence.entries())
      .filter(([pair, weight]) => weight >= minConnections)
      .map(([pair, weight]) => {
        const [source, target] = pair.split('|');
        return { source, target, weight };
      });
    
    // Count connections per node
    const connectionCounts = new Map();
    links.forEach(link => {
      connectionCounts.set(link.source, (connectionCounts.get(link.source) || 0) + 1);
      connectionCounts.set(link.target, (connectionCounts.get(link.target) || 0) + 1);
    });
    
    // Filter nodes that have connections
    const filteredNodes = nodes.filter(node => {
      node.connections = connectionCounts.get(node.id) || 0;
      return node.connections > 0;
    });
    
    return { nodes: filteredNodes, links };
  }
  
  // Network visualisation
  function createNetwork(data, nodeSizeMultiplier = 1) {
    const container = d3.select('#network-container');
    const svg = d3.select('#network-svg');
    const tooltip = d3.select('#tooltip');
    
    svg.selectAll('*').remove();
    
    const width = container.node().offsetWidth;
    const height = container.node().offsetHeight;
    
    const simulation = d3.forceSimulation(data.nodes)
      .force('link', d3.forceLink(data.links).id(d => d.id).distance(80))
      .force('charge', d3.forceManyBody().strength(-300))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(d => Math.sqrt(d.frequency) * 8 * nodeSizeMultiplier + 5));
    
    // Add zoom behaviour
    const zoom = d3.zoom()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
      });
    
    svg.call(zoom);
    
    const g = svg.append('g');
    
    // Create links
    const link = g.append('g')
      .selectAll('line')
      .data(data.links)
      .join('line')
      .attr('class', 'link')
      .attr('stroke-width', d => Math.sqrt(d.weight) * 2);
    
    // Create nodes
    const node = g.append('g')
      .selectAll('circle')
      .data(data.nodes)
      .join('circle')
      .attr('class', 'node')
      .attr('r', d => Math.sqrt(d.frequency) * 8 * nodeSizeMultiplier)
      .attr('fill', '#1f77b4')
      .call(d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended))
      .on('mouseover', function(event, d) {
        tooltip
          .style('opacity', 1)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 10) + 'px')
          .html(`
            <strong>${d.id}</strong><br>
            Frequency: ${d.frequency} books<br>
            Connections: ${d.connections}
          `);
        
        // Highlight connected nodes and links
        const connectedNodes = new Set();
        connectedNodes.add(d.id);
        
        link
          .style('stroke-opacity', l => 
            l.source.id === d.id || l.target.id === d.id ? 1 : 0.1)
          .style('stroke-width', l => 
            l.source.id === d.id || l.target.id === d.id ? Math.sqrt(l.weight) * 3 : Math.sqrt(l.weight) * 2);
        
        data.links.forEach(l => {
          if (l.source.id === d.id) connectedNodes.add(l.target.id);
          if (l.target.id === d.id) connectedNodes.add(l.source.id);
        });
        
        node.style('opacity', n => connectedNodes.has(n.id) ? 1 : 0.3);
      })
      .on('mouseout', function() {
        tooltip.style('opacity', 0);
        link.style('stroke-opacity', 0.6).style('stroke-width', d => Math.sqrt(d.weight) * 2);
        node.style('opacity', 1);
      });
    
    // Add labels
    const label = g.append('g')
      .selectAll('text')
      .data(data.nodes)
      .join('text')
      .attr('class', 'node-label')
      .text(d => d.id)
      .style('font-size', d => Math.max(10, Math.sqrt(d.frequency) * 2 * nodeSizeMultiplier) + 'px');
    
    // Update positions on tick
    simulation.on('tick', () => {
      link
        .attr('x1', d => d.source.x)
        .attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x)
        .attr('y2', d => d.target.y);
      
      node
        .attr('cx', d => d.x)
        .attr('cy', d => d.y);
      
      label
        .attr('x', d => d.x)
        .attr('y', d => d.y + 4);
    });
    
    // Reset zoom function
    window.resetNetworkZoom = function() {
      svg.transition().duration(750).call(
        zoom.transform,
        d3.zoomIdentity.translate(0, 0).scale(1)
      );
    };
    
    function dragstarted(event) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }
    
    function dragged(event) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }
    
    function dragended(event) {
      if (!event.active) simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }
  }
  
  // Generate analysis text
  function generateAnalysis(data) {
    const totalThemes = data.nodes.length;
    const totalConnections = data.links.length;
    const avgConnections = totalConnections > 0 ? (data.links.reduce((sum, l) => sum + l.weight, 0) / totalConnections).toFixed(1) : 0;
    
    // Find most connected themes
    const topThemes = data.nodes
      .sort((a, b) => b.connections - a.connections)
      .slice(0, 5);
    
    // Find strongest connections
    const strongestLinks = data.links
      .sort((a, b) => b.weight - a.weight)
      .slice(0, 5);
    
    const analysisHTML = `
      <h3>Network Overview</h3>
      <p>The theme network reveals patterns of thematic clustering within the artfiction corpus. Themes that frequently appear together in novels form dense clusters, suggesting shared conceptual territories.</p>
      
      <h3>Most Connected Themes</h3>
      <ol>
        ${topThemes.map(theme => 
          `<li><strong>${theme.id}</strong> - ${theme.connections} connections, appears in ${theme.frequency} novels</li>`
        ).join('')}
      </ol>
      
      <h3>Strongest Thematic Relationships</h3>
      <ol>
        ${strongestLinks.map(link => 
          `<li><strong>${link.source.id || link.source}</strong> ↔ <strong>${link.target.id || link.target}</strong> (${link.weight} novels)</li>`
        ).join('')}
      </ol>
      
      <h3>Network Patterns</h3>
      <p>The visualisation suggests several thematic clusters that reflect different aspects of contemporary Latin American and Iberian fiction. Central themes like "Artistic Education" and "Alternative (art) worlds" act as bridges between different thematic communities, indicating their role as cross-cutting concerns in artfiction.</p>
    `;
    
    document.getElementById('analysis-content').innerHTML = analysisHTML;
  }
  
  // Update stats
  function updateStats(data) {
    const totalNovels = novels.length;
    const uniqueThemes = new Set();
    novels.forEach(n => n.__themes.forEach(t => uniqueThemes.add(t)));
    
    const statsHTML = `
      <div class="stat-card">
        <div class="stat-value">${totalNovels}</div>
        <div class="stat-label">Total Novels</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${uniqueThemes.size}</div>
        <div class="stat-label">Unique Themes</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${data.nodes.length}</div>
        <div class="stat-label">Connected Themes</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${data.links.length}</div>
        <div class="stat-label">Theme Connections</div>
      </div>
    `;
    
    document.getElementById('stats').innerHTML = statsHTML;
  }
  
  // Controls
  const minConnectionsSlider = document.getElementById('minConnections');
  const minConnectionsValue = document.getElementById('minConnectionsValue');
  const nodeSizeSlider = document.getElementById('nodeSize');
  const nodeSizeValue = document.getElementById('nodeSizeValue');
  const resetButton = document.getElementById('resetZoom');
  
  function updateVisualization() {
    const minConnections = parseInt(minConnectionsSlider.value);
    const nodeSizeMultiplier = parseFloat(nodeSizeSlider.value);
    
    const data = buildNetworkData(minConnections);
    createNetwork(data, nodeSizeMultiplier);
    updateStats(data);
    generateAnalysis(data);
  }
  
  minConnectionsSlider.addEventListener('input', () => {
    minConnectionsValue.textContent = minConnectionsSlider.value;
    updateVisualization();
  });
  
  nodeSizeSlider.addEventListener('input', () => {
    nodeSizeValue.textContent = parseFloat(nodeSizeSlider.value).toFixed(1);
    updateVisualization();
  });
  
  resetButton.addEventListener('click', () => {
    if (window.resetNetworkZoom) {
      window.resetNetworkZoom();
    }
  });
  
  // Initial render
  updateVisualization();
  
  // Handle window resize
  window.addEventListener('resize', () => {
    setTimeout(updateVisualization, 100);
  });
})();
</script>
</body>
</html>