<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Network Analysis - Artfictions</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />
  <style>
    #network-container {
      width: 100%;
      height: 70vh;
      border: 1px solid var(--grey-mid);
      border-radius: 4px;
      margin: 1rem 0;
      background: var(--bg);
      position: relative;
    }
    
    #network-svg {
      width: 100%;
      height: 100%;
    }
    
    .node {
      stroke: #333;
      stroke-width: 2px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .node:hover {
      stroke-width: 4px;
    }
    
    .link {
      stroke: #999;
      stroke-opacity: 0.6;
    }
    
    .node-label {
      font-family: Inter, sans-serif;
      font-size: 10px;
      font-weight: 600;
      text-anchor: middle;
      pointer-events: none;
      fill: #333;
    }
    
    .tooltip {
      position: absolute;
      background: #333;
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 1000;
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin: 1rem 0;
      padding: 1rem;
      background: var(--grey-light);
      border-radius: 4px;
    }
    
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .control-group label {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--grey-dark);
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }
    
    .stat-card {
      padding: 1rem;
      background: var(--grey-light);
      border-radius: 4px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--fg);
    }
    
    .stat-label {
      font-size: 0.9rem;
      color: var(--grey-dark);
      margin-top: 0.5rem;
    }
    
    .back-link {
      display: inline-block;
      margin-bottom: 1rem;
      color: var(--fg);
      text-decoration: none;
      font-weight: 600;
    }
    
    .back-link:hover {
      text-decoration: underline;
    }
    
    .debug {
      background: #f8f8f8;
      padding: 1rem;
      border-radius: 4px;
      margin: 1rem 0;
      font-family: monospace;
      font-size: 0.9rem;
      border-left: 4px solid #007acc;
    }
    
    #status {
      background: var(--grey-light);
      padding: 1rem;
      border-radius: 4px;
      margin: 1rem 0;
      font-weight: 600;
    }
  </style>
</head>
<body>
<main>
  <a href="index.html" class="back-link">← Back to Catalogue</a>
  
  <h1>Theme Network Analysis</h1>
  
  <p>This network shows how themes co-occur across novels in the artfiction corpus. Nodes represent themes, and connections show themes that appear together in the same novels.</p>
  
  <div id="status">Loading...</div>
  
  <div class="controls">
    <div class="control-group">
      <label for="minConnections">Minimum connections</label>
      <input type="range" id="minConnections" min="1" max="10" value="2" step="1">
      <span id="minConnectionsValue">2</span>
    </div>
    
    <button type="button" id="updateNetwork">Update Network</button>
    <button type="button" id="resetView">Reset View</button>
  </div>
  
  <div class="stats" id="stats"></div>
  
  <div id="network-container">
    <svg id="network-svg"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>
  
  <div id="debug" class="debug"></div>
  
  <div id="analysis">
    <h2>Analysis</h2>
    <div id="analysis-content">
      <p>Network will appear here once loaded...</p>
    </div>
  </div>
</main>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
// Debug function
function debug(message, data = null) {
  console.log(message, data);
  const debugEl = document.getElementById('debug');
  debugEl.innerHTML += `<div>${message} ${data ? JSON.stringify(data).substring(0, 100) : ''}</div>`;
}

function updateStatus(message) {
  document.getElementById('status').textContent = message;
}

// Main application
async function init() {
  try {
    updateStatus('Checking D3...');
    
    // Check if D3 loaded
    if (typeof d3 === 'undefined') {
      throw new Error('D3.js failed to load');
    }
    debug('✓ D3.js loaded successfully');
    
    updateStatus('Loading data...');
    
    // Load data
    const response = await fetch('artfictions_novels.json');
    if (!response.ok) {
      throw new Error(`Failed to load data: ${response.status}`);
    }
    
    const data = await response.json();
    debug('✓ Data loaded', { keys: Object.keys(data) });
    
    let novels = Array.isArray(data) ? data : data.Novels || [];
    if (!Array.isArray(novels)) {
      throw new Error('Could not find novels array in data');
    }
    
    debug(`✓ Found ${novels.length} novels`);
    
    updateStatus('Processing themes...');
    
    // Process themes
    const themeFreq = new Map();
    const themeCooccurrence = new Map();
    
    novels.forEach((novel, index) => {
      const themes = [];
      
      // Extract themes
      for (let i = 1; i <= 5; i++) {
        const theme = novel[`Theme ${i}`];
        if (theme && theme.trim() && theme.trim() !== '') {
          themes.push(theme.trim());
        }
      }
      
      if (themes.length === 0) return;
      
      // Count theme frequencies
      themes.forEach(theme => {
        themeFreq.set(theme, (themeFreq.get(theme) || 0) + 1);
      });
      
      // Count co-occurrences
      for (let i = 0; i < themes.length; i++) {
        for (let j = i + 1; j < themes.length; j++) {
          const pair = [themes[i], themes[j]].sort().join('|||');
          themeCooccurrence.set(pair, (themeCooccurrence.get(pair) || 0) + 1);
        }
      }
    });
    
    debug(`✓ Found ${themeFreq.size} unique themes`);
    debug(`✓ Found ${themeCooccurrence.size} theme pairs`);
    
    // Store data globally
    window.appData = {
      novels,
      themeFreq,
      themeCooccurrence
    };
    
    updateStatus('Building network...');
    buildNetwork();
    
  } catch (error) {
    debug('✗ Error:', error.message);
    updateStatus(`Error: ${error.message}`);
    document.getElementById('analysis-content').innerHTML = `
      <p style="color: #b00;">Failed to load network: ${error.message}</p>
      <p>Please check that:</p>
      <ul>
        <li>The artfictions_novels.json file is in the same directory</li>
        <li>Your browser supports modern JavaScript</li>
        <li>You're viewing this through a web server (not file://)</li>
      </ul>
    `;
  }
}

function buildNetwork() {
  try {
    const minConnections = parseInt(document.getElementById('minConnections').value);
    const { themeFreq, themeCooccurrence } = window.appData;
    
    debug(`Building network with min connections: ${minConnections}`);
    
    // Create nodes (top 30 themes by frequency)
    const nodes = Array.from(themeFreq.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 30)
      .map(([theme, freq]) => ({
        id: theme,
        frequency: freq,
        connections: 0
      }));
    
    const nodeIds = new Set(nodes.map(n => n.id));
    
    // Create links
    const links = Array.from(themeCooccurrence.entries())
      .filter(([pair, weight]) => {
        const [source, target] = pair.split('|||');
        return weight >= minConnections && nodeIds.has(source) && nodeIds.has(target);
      })
      .map(([pair, weight]) => {
        const [source, target] = pair.split('|||');
        return { source, target, weight };
      });
    
    debug(`Created ${nodes.length} nodes and ${links.length} links`);
    
    if (links.length === 0) {
      updateStatus('No connections found - try reducing minimum connections');
      return;
    }
    
    // Count actual connections
    const connectionCounts = new Map();
    links.forEach(link => {
      connectionCounts.set(link.source, (connectionCounts.get(link.source) || 0) + 1);
      connectionCounts.set(link.target, (connectionCounts.get(link.target) || 0) + 1);
    });
    
    nodes.forEach(node => {
      node.connections = connectionCounts.get(node.id) || 0;
    });
    
    // Filter nodes with connections
    const connectedNodes = nodes.filter(n => n.connections > 0);
    
    debug(`${connectedNodes.length} nodes have connections`);
    
    // Visualize
    visualizeNetwork({ nodes: connectedNodes, links });
    updateStats(connectedNodes, links);
    generateAnalysis(connectedNodes, links);
    
    updateStatus('✓ Network ready');
    
  } catch (error) {
    debug('✗ Error building network:', error.message);
    updateStatus(`Error building network: ${error.message}`);
  }
}

function visualizeNetwork(data) {
  const container = document.getElementById('network-container');
  const svg = d3.select('#network-svg');
  const tooltip = d3.select('#tooltip');
  
  svg.selectAll('*').remove();
  
  const width = container.offsetWidth;
  const height = container.offsetHeight;
  
  debug(`Visualizing ${data.nodes.length} nodes in ${width}x${height} area`);
  
  // Create simulation
  const simulation = d3.forceSimulation(data.nodes)
    .force('link', d3.forceLink(data.links).id(d => d.id).distance(80))
    .force('charge', d3.forceManyBody().strength(-300))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collision', d3.forceCollide().radius(d => Math.sqrt(d.frequency) * 5 + 10));
  
  // Add zoom
  const zoom = d3.zoom()
    .scaleExtent([0.1, 4])
    .on('zoom', (event) => {
      g.attr('transform', event.transform);
    });
  
  svg.call(zoom);
  
  const g = svg.append('g');
  
  // Create links
  const link = g.append('g')
    .selectAll('line')
    .data(data.links)
    .join('line')
    .attr('class', 'link')
    .attr('stroke-width', d => Math.sqrt(d.weight) * 2);
  
  // Create nodes
  const node = g.append('g')
    .selectAll('circle')
    .data(data.nodes)
    .join('circle')
    .attr('class', 'node')
    .attr('r', d => Math.sqrt(d.frequency) * 5 + 5)
    .attr('fill', '#1f77b4')
    .call(d3.drag()
      .on('start', dragstarted)
      .on('drag', dragged)
      .on('end', dragended))
    .on('mouseover', function(event, d) {
      tooltip
        .style('opacity', 1)
        .style('left', (event.pageX + 10) + 'px')
        .style('top', (event.pageY - 10) + 'px')
        .html(`
          <strong>${d.id}</strong><br>
          Appears in ${d.frequency} novels<br>
          ${d.connections} connections
        `);
      
      // Highlight connections
      const connected = new Set([d.id]);
      data.links.forEach(l => {
        if (l.source.id === d.id) connected.add(l.target.id);
        if (l.target.id === d.id) connected.add(l.source.id);
      });
      
      node.style('opacity', n => connected.has(n.id) ? 1 : 0.3);
      link.style('opacity', l => 
        l.source.id === d.id || l.target.id === d.id ? 1 : 0.1
      );
    })
    .on('mouseout', function() {
      tooltip.style('opacity', 0);
      node.style('opacity', 1);
      link.style('opacity', 0.6);
    });
  
  // Add labels
  const label = g.append('g')
    .selectAll('text')
    .data(data.nodes)
    .join('text')
    .attr('class', 'node-label')
    .text(d => d.id.length > 15 ? d.id.substring(0, 15) + '...' : d.id);
  
  // Update positions
  simulation.on('tick', () => {
    link
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);
    
    node
      .attr('cx', d => d.x)
      .attr('cy', d => d.y);
    
    label
      .attr('x', d => d.x)
      .attr('y', d => d.y + 4);
  });
  
  // Reset view function
  window.resetNetworkView = function() {
    svg.transition().duration(750).call(
      zoom.transform,
      d3.zoomIdentity
    );
  };
  
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }
  
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }
  
  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }
}

function updateStats(nodes, links) {
  const totalNovels = window.appData.novels.length;
  const avgConnections = nodes.length > 0 ? (links.length * 2 / nodes.length).toFixed(1) : 0;
  
  document.getElementById('stats').innerHTML = `
    <div class="stat-card">
      <div class="stat-value">${totalNovels}</div>
      <div class="stat-label">Total Novels</div>
    </div>
    <div class="stat-card">
      <div class="stat-value">${nodes.length}</div>
      <div class="stat-label">Connected Themes</div>
    </div>
    <div class="stat-card">
      <div class="stat-value">${links.length}</div>
      <div class="stat-label">Theme Connections</div>
    </div>
    <div class="stat-card">
      <div class="stat-value">${avgConnections}</div>
      <div class="stat-label">Avg Connections</div>
    </div>
  `;
}

function generateAnalysis(nodes, links) {
  const topThemes = nodes
    .sort((a, b) => b.connections - a.connections)
    .slice(0, 5);
  
  const strongestLinks = links
    .sort((a, b) => b.weight - a.weight)
    .slice(0, 5);
  
  document.getElementById('analysis-content').innerHTML = `
    <h3>Most Connected Themes</h3>
    <ol>
      ${topThemes.map(theme => 
        `<li><strong>${theme.id}</strong> - ${theme.connections} connections, ${theme.frequency} novels</li>`
      ).join('')}
    </ol>
    
    <h3>Strongest Theme Relationships</h3>
    <ol>
      ${strongestLinks.map(link => 
        `<li><strong>${link.source.id || link.source}</strong> ↔ <strong>${link.target.id || link.target}</strong> (${link.weight} novels)</li>`
      ).join('')}
    </ol>
    
    <p>The network reveals how themes cluster together in the artfiction corpus. Central themes act as bridges between different thematic communities.</p>
  `;
}

// Event listeners
document.addEventListener('DOMContentLoaded', function() {
  debug('✓ DOM loaded');
  
  document.getElementById('minConnections').addEventListener('input', function() {
    document.getElementById('minConnectionsValue').textContent = this.value;
  });
  
  document.getElementById('updateNetwork').addEventListener('click', function() {
    if (window.appData) {
      buildNetwork();
    }
  });
  
  document.getElementById('resetView').addEventListener('click', function() {
    if (window.resetNetworkView) {
      window.resetNetworkView();
    }
  });
  
  // Start the app
  init();
});
</script>
</body>
</html>
